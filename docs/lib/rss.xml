<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Flowres - Hardware]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>lib/media/favicon.png</url><title>Flowres - Hardware</title><link/></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Sun, 16 Mar 2025 17:27:40 GMT</lastBuildDate><atom:link href="lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Sun, 16 Mar 2025 17:27:37 GMT</pubDate><copyright><![CDATA[David Jun]]></copyright><ttl>60</ttl><dc:creator>David Jun</dc:creator><item><title><![CDATA[<% tp.file.title.replace(/^[a-zA-Z0-9]+ /, "") %>]]></title><description><![CDATA[ 
 <br><br>
<br>
<br>a-zA-Z0-9<a href="about:blank#fnref-1-2de69f7a2ce1c40f" class="footnote-backref footnote-link" target="_self" rel="noopener nofollow">↩︎</a>
]]></description><link>templates/basic.html</link><guid isPermaLink="false">Templates/Basic.md</guid><dc:creator><![CDATA[David Jun]]></dc:creator><pubDate>Sun, 16 Mar 2025 15:57:04 GMT</pubDate></item><item><title><![CDATA[Analog flow sensors]]></title><description><![CDATA[ 
 <br><br>This type of sensors needs to be interfaced through an additional layer of <a data-tooltip-position="top" aria-label="04aa Analog to digital conversion" data-href="04aa Analog to digital conversion" href="04aa-analog-to-digital-conversion.html" class="internal-link" target="_self" rel="noopener nofollow">analog-to-digital converter</a>, which gives voltage readings later translated into the physical flow rate values.<br>In terms of the <a data-href="target flow rates" href="target flow rates" class="internal-link" target="_self" rel="noopener nofollow">target flow rates</a>, there few options, which would not bee too expensive:<br>
<br><a data-href="00aa01 Omron D6F-P" href="00aa01-omron-d6f-p.html" class="internal-link" target="_self" rel="noopener nofollow">00aa01 Omron D6F-P</a>
<br><a data-href="00aa02 Omron D6F-A3" href="00aa02-omron-d6f-a3.html" class="internal-link" target="_self" rel="noopener nofollow">00aa02 Omron D6F-A3</a>
<br><a data-href="00aa03 Omron D6FV03A1" href="00aa03 Omron D6FV03A1" class="internal-link" target="_self" rel="noopener nofollow">00aa03 Omron D6FV03A1</a>
]]></description><link>00aa-analog-flow-sensors.html</link><guid isPermaLink="false">00aa Analog flow sensors.md</guid><dc:creator><![CDATA[David Jun]]></dc:creator><pubDate>Sun, 16 Mar 2025 15:52:04 GMT</pubDate></item><item><title><![CDATA[Digital flow sensors]]></title><description><![CDATA[ 
 <br><br>At the time of writing, there was not suitable digital flow sensor found, which would compare in terms of flow rate range and value to the <a data-href="00aa Analog flow sensors" href="00aa-analog-flow-sensors.html" class="internal-link" target="_self" rel="noopener nofollow">00aa Analog flow sensors</a>.]]></description><link>00ab-digital-flow-sensors.html</link><guid isPermaLink="false">00ab Digital flow sensors.md</guid><dc:creator><![CDATA[David Jun]]></dc:creator><pubDate>Sun, 16 Mar 2025 16:37:58 GMT</pubDate></item><item><title><![CDATA[Digital differential pressure sensors]]></title><description><![CDATA[ 
 <br><br>
<br><a data-href="01aa01 Sensirion SDP610-25PA" href="01aa01-sensirion-sdp610-25pa.html" class="internal-link" target="_self" rel="noopener nofollow">01aa01 Sensirion SDP610-25PA</a>
<br><a data-href="01aa02 Sensirion SDP810-125PA" href="01aa02-sensirion-sdp810-125pa.html" class="internal-link" target="_self" rel="noopener nofollow">01aa02 Sensirion SDP810-125PA</a>
]]></description><link>01aa-digital-differential-pressure-sensors.html</link><guid isPermaLink="false">01aa Digital differential pressure sensors.md</guid><dc:creator><![CDATA[David Jun]]></dc:creator><pubDate>Sun, 16 Mar 2025 16:38:16 GMT</pubDate></item><item><title><![CDATA[Sensirion SDP610-25PA]]></title><description><![CDATA[ 
 <br><br><img alt="Attachments/01aa01 Sensirion SDP610-25PA.png" src="attachments/01aa01-sensirion-sdp610-25pa.png" style="width: 300px; max-width: 100%;"><br>A <a data-tooltip-position="top" aria-label="01aa Digital differential pressure sensors" data-href="01aa Digital differential pressure sensors" href="01aa-digital-differential-pressure-sensors.html" class="internal-link" target="_self" rel="noopener nofollow">digital differential pressure sensor</a>, originally used in the setup made for David's thesis.<br>It is interfaced using I2C protocol, which is rather straight forward on <a data-tooltip-position="top" aria-label="04ab RaspberryPi GPIO header utilization" data-href="04ab RaspberryPi GPIO header utilization" href="04ab-raspberrypi-gpio-header-utilization.html" class="internal-link" target="_self" rel="noopener nofollow">Raspberry Pi SBCs</a>.<br>Priced at approx. €40 (<a data-tooltip-position="top" aria-label="https://cz.farnell.com/sensirion/sdp610-025pa/pressure-transducer-lin-25-to/dp/2085061" rel="noopener nofollow" class="external-link" href="https://cz.farnell.com/sensirion/sdp610-025pa/pressure-transducer-lin-25-to/dp/2085061" target="_blank">farnell</a>).<br><br>
<br>measurement range: -25 to 25 Pa
<br>zero-point accuracy: 0.1 Pa
<br>accuracy: 3% of reading
<br><br>Given the <a data-tooltip-position="top" aria-label="https://claude.ai/" rel="noopener nofollow" class="external-link" href="https://claude.ai/" target="_blank">Claude AI</a>. Should be debugged for later use. Consult also with the other response in <a data-href="01aa02 Sensirion SDP810-125PA" href="01aa02-sensirion-sdp810-125pa.html" class="internal-link" target="_self" rel="noopener nofollow">01aa02 Sensirion SDP810-125PA</a> which gives some more functions for a better cleanup.<br>import smbus
import time

class SDP610:
    # Default I2C address for SDP610
    DEFAULT_ADDRESS = 0x40
    
    # Commands
    TRIGGER_MEASUREMENT = 0xF1
    SOFT_RESET = 0xFE
    
    def __init__(self, bus_num=1, address=DEFAULT_ADDRESS):
        """Initialize the SDP610 sensor."""
        self.bus = smbus.SMBus(bus_num)
        self.address = address
        
        # Reset the sensor at startup
        self.reset()
        time.sleep(0.1)  # Wait for reset to complete
    
    def reset(self):
        """Perform a soft reset of the sensor."""
        try:
            self.bus.write_byte(self.address, self.SOFT_RESET)
            return True
        except Exception as e:
            print(f"Error resetting sensor: {e}")
            return False
    
    def read_pressure(self):
        """Read differential pressure value in Pascal."""
        try:
            # Trigger measurement
            self.bus.write_byte(self.address, self.TRIGGER_MEASUREMENT)
            time.sleep(0.1)  # Wait for measurement to complete
            
            # Read 3 bytes (2 for pressure, 1 for CRC)
            data = self.bus.read_i2c_block_data(self.address, 0, 3)
            
            # Convert the data
            raw_pressure = (data[0] &lt;&lt; 8) | data[1]
            
            # For SDP610-25PA, scale factor is 240
            # See datasheet for details
            pressure_pa = raw_pressure / 240.0
            
            return pressure_pa
        except Exception as e:
            print(f"Error reading pressure: {e}")
            return None

# Example usage
if __name__ == "__main__":
    # Initialize sensor
    sensor = SDP610()
    
    try:
        while True:
            pressure = sensor.read_pressure()
            if pressure is not None:
                print(f"Differential Pressure: {pressure:.2f} Pa")
            time.sleep(1)
    except KeyboardInterrupt:
        print("Measurement stopped by user")
<br><br><a data-tooltip-position="top" aria-label="Attachments/datasheets/SDP600.pdf" data-href="Attachments/datasheets/SDP600.pdf" href="attachments/datasheets/sdp600.pdf" class="internal-link" target="_self" rel="noopener nofollow">SDP6xx</a>]]></description><link>01aa01-sensirion-sdp610-25pa.html</link><guid isPermaLink="false">01aa01 Sensirion SDP610-25PA.md</guid><dc:creator><![CDATA[David Jun]]></dc:creator><pubDate>Sun, 16 Mar 2025 17:05:46 GMT</pubDate><enclosure url="attachments/01aa01-sensirion-sdp610-25pa.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="attachments/01aa01-sensirion-sdp610-25pa.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Sensirion SDP810-125PA]]></title><description><![CDATA[ 
 <br><br><img alt="Attachments/01aa02 Sensirion SDP810-125PA.png" src="attachments/01aa02-sensirion-sdp810-125pa.png" style="width: 300px; max-width: 100%;"><br>A <a data-tooltip-position="top" aria-label="01aa Digital differential pressure sensors" data-href="01aa Digital differential pressure sensors" href="01aa-digital-differential-pressure-sensors.html" class="internal-link" target="_self" rel="noopener nofollow">digital differential pressure sensor</a>, successor of the <a data-href="01aa01 Sensirion SDP610-25PA" href="01aa01-sensirion-sdp610-25pa.html" class="internal-link" target="_self" rel="noopener nofollow">01aa01 Sensirion SDP610-25PA</a>.<br>It is interfaced using I2C protocol, which is rather straight forward on <a data-tooltip-position="top" aria-label="04ab RaspberryPi GPIO header utilization" data-href="04ab RaspberryPi GPIO header utilization" href="04ab-raspberrypi-gpio-header-utilization.html" class="internal-link" target="_self" rel="noopener nofollow">Raspberry Pi SBCs</a>.<br>Priced at approx. €30 (<a data-tooltip-position="top" aria-label="https://cz.farnell.com/sensirion/sdp810-125pa/pressure-sensor-diff-125pa-digital/dp/2886665" rel="noopener nofollow" class="external-link" href="https://cz.farnell.com/sensirion/sdp810-125pa/pressure-sensor-diff-125pa-digital/dp/2886665" target="_blank">farnell</a>).<br><br>
<br>measurement range: -125 to 125 Pa
<br>zero-point accuracy: 0.08 Pa
<br>accuracy: 3% of reading
<br>This means it is a cheaper, more or similarly accurate product compared to <a data-href="01aa01 Sensirion SDP610-25PA" href="01aa01-sensirion-sdp610-25pa.html" class="internal-link" target="_self" rel="noopener nofollow">01aa01 Sensirion SDP610-25PA</a>, which is also suitable for a wider pressure range.<br><br>Given the <a data-tooltip-position="top" aria-label="https://claude.ai/" rel="noopener nofollow" class="external-link" href="https://claude.ai/" target="_blank">Claude AI</a>. Should be debugged for later use.<br>import smbus
import time

class SDP810:
    # Default I2C address for SDP810
    DEFAULT_ADDRESS = 0x25  # Note: SDP810 default address is 0x25 (may vary by variant)
    
    # Commands
    START_CONTINUOUS_MEASUREMENT = 0x3603
    STOP_MEASUREMENT = 0x3FF9
    SOFT_RESET = 0x0006
    
    def __init__(self, bus_num=1, address=DEFAULT_ADDRESS):
        """Initialize the SDP810 sensor."""
        self.bus = smbus.SMBus(bus_num)
        self.address = address
        
        # Reset the sensor at startup
        self.reset()
        time.sleep(0.1)  # Wait for reset to complete
        
        # Start continuous measurement
        self.start_measurement()
        time.sleep(0.1)  # Wait for command to take effect
    
    def reset(self):
        """Perform a soft reset of the sensor."""
        try:
            self.bus.write_i2c_block_data(self.address, 0x00, [(self.SOFT_RESET &gt;&gt; 8) &amp; 0xFF, self.SOFT_RESET &amp; 0xFF])
            return True
        except Exception as e:
            print(f"Error resetting sensor: {e}")
            return False
    
    def start_measurement(self):
        """Start continuous measurement mode."""
        try:
            self.bus.write_i2c_block_data(self.address, 0x36, [0x03])
            return True
        except Exception as e:
            print(f"Error starting measurement: {e}")
            return False
    
    def stop_measurement(self):
        """Stop continuous measurement mode."""
        try:
            self.bus.write_i2c_block_data(self.address, 0x3F, [0xF9])
            return True
        except Exception as e:
            print(f"Error stopping measurement: {e}")
            return False
    
    def read_pressure(self):
        """Read differential pressure value in Pascal."""
        try:
            # Read 3 bytes (2 for pressure, 1 for CRC)
            data = self.bus.read_i2c_block_data(self.address, 0x00, 3)
            
            # Convert the data
            raw_pressure = (data[0] &lt;&lt; 8) | data[1]
            
            # For SDP810-125Pa, scale factor is 60
            # See datasheet for details
            pressure_pa = raw_pressure / 60.0
            
            return pressure_pa
        except Exception as e:
            print(f"Error reading pressure: {e}")
            return None
    
    def __del__(self):
        """Clean up when object is deleted."""
        try:
            self.stop_measurement()
        except:
            pass

# Example usage
if __name__ == "__main__":
    # Initialize sensor
    sensor = SDP810()
    
    try:
        while True:
            pressure = sensor.read_pressure()
            if pressure is not None:
                print(f"Differential Pressure: {pressure:.2f} Pa")
            time.sleep(1)
    except KeyboardInterrupt:
        print("Measurement stopped by user")
        sensor.stop_measurement()
<br><br><a data-tooltip-position="top" aria-label="Attachments/datasheets/SDP800.pdf" data-href="Attachments/datasheets/SDP800.pdf" href="attachments/datasheets/sdp800.pdf" class="internal-link" target="_self" rel="noopener nofollow">SDP810</a>]]></description><link>01aa02-sensirion-sdp810-125pa.html</link><guid isPermaLink="false">01aa02 Sensirion SDP810-125PA.md</guid><dc:creator><![CDATA[David Jun]]></dc:creator><pubDate>Sun, 16 Mar 2025 17:16:10 GMT</pubDate><enclosure url="attachments/01aa02-sensirion-sdp810-125pa.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="attachments/01aa02-sensirion-sdp810-125pa.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[02aa Compressor]]></title><description><![CDATA[ 
 ]]></description><link>02aa-compressor.html</link><guid isPermaLink="false">02aa Compressor.md</guid><dc:creator><![CDATA[David Jun]]></dc:creator><pubDate>Sun, 16 Mar 2025 13:06:01 GMT</pubDate></item><item><title><![CDATA[02ab DC ventilator]]></title><description><![CDATA[ 
 ]]></description><link>02ab-dc-ventilator.html</link><guid isPermaLink="false">02ab DC ventilator.md</guid><dc:creator><![CDATA[David Jun]]></dc:creator><pubDate>Sun, 16 Mar 2025 13:06:07 GMT</pubDate></item><item><title><![CDATA[02ac Water tank]]></title><description><![CDATA[ 
 ]]></description><link>02ac-water-tank.html</link><guid isPermaLink="false">02ac Water tank.md</guid><dc:creator><![CDATA[David Jun]]></dc:creator><pubDate>Sun, 16 Mar 2025 13:06:09 GMT</pubDate></item><item><title><![CDATA[03aa Electromagnetic valve]]></title><description><![CDATA[ 
 ]]></description><link>03aa-electromagnetic-valve.html</link><guid isPermaLink="false">03aa Electromagnetic valve.md</guid><dc:creator><![CDATA[David Jun]]></dc:creator><pubDate>Sun, 16 Mar 2025 13:06:12 GMT</pubDate></item><item><title><![CDATA[03ab PWM ventilator operation]]></title><description><![CDATA[ 
 ]]></description><link>03ab-pwm-ventilator-operation.html</link><guid isPermaLink="false">03ab PWM ventilator operation.md</guid><dc:creator><![CDATA[David Jun]]></dc:creator><pubDate>Sun, 16 Mar 2025 13:06:15 GMT</pubDate></item><item><title><![CDATA[Analog to digital conversion]]></title><description><![CDATA[ 
 <br><br>Analog-to-digital converters (ADCs) help to interface analog sensors, which output only voltage values. These values are translated to the physical quantity values using ADC and additional software layer. <br><a data-href="04aa01 ADS1115 chip (I2C)" href="04aa01-ads1115-chip-(i2c).html" class="internal-link" target="_self" rel="noopener nofollow">04aa01 ADS1115 chip (I2C)</a>]]></description><link>04aa-analog-to-digital-conversion.html</link><guid isPermaLink="false">04aa Analog to digital conversion.md</guid><dc:creator><![CDATA[David Jun]]></dc:creator><pubDate>Sun, 16 Mar 2025 17:14:54 GMT</pubDate></item><item><title><![CDATA[04ab RaspberryPi GPIO header utilization]]></title><description><![CDATA[ 
 ]]></description><link>04ab-raspberrypi-gpio-header-utilization.html</link><guid isPermaLink="false">04ab RaspberryPi GPIO header utilization.md</guid><dc:creator><![CDATA[David Jun]]></dc:creator><pubDate>Sun, 16 Mar 2025 13:07:07 GMT</pubDate></item><item><title><![CDATA[Navigation]]></title><description><![CDATA[ 
 <br><br><br>
<br><a data-href="00aa Analog flow sensors" href="00aa-analog-flow-sensors.html" class="internal-link" target="_self" rel="noopener nofollow">00aa Analog flow sensors</a>
<br><a data-href="00ab Digital flow sensors" href="00ab-digital-flow-sensors.html" class="internal-link" target="_self" rel="noopener nofollow">00ab Digital flow sensors</a>
<br><br>
<br><a data-href="01aa Digital differential pressure sensors" href="01aa-digital-differential-pressure-sensors.html" class="internal-link" target="_self" rel="noopener nofollow">01aa Digital differential pressure sensors</a>
<br><br>
<br><a data-href="02aa Compressor" href="02aa-compressor.html" class="internal-link" target="_self" rel="noopener nofollow">02aa Compressor</a>
<br><a data-href="02ab DC ventilator" href="02ab-dc-ventilator.html" class="internal-link" target="_self" rel="noopener nofollow">02ab DC ventilator</a>
<br><a data-href="02ac Water tank" href="02ac-water-tank.html" class="internal-link" target="_self" rel="noopener nofollow">02ac Water tank</a>
<br><br>
<br><a data-href="03aa Electromagnetic valve" href="03aa-electromagnetic-valve.html" class="internal-link" target="_self" rel="noopener nofollow">03aa Electromagnetic valve</a>
<br><a data-href="03ab PWM ventilator operation" href="03ab-pwm-ventilator-operation.html" class="internal-link" target="_self" rel="noopener nofollow">03ab PWM ventilator operation</a>
<br><br>
<br><a data-href="04aa Analog to digital conversion" href="04aa-analog-to-digital-conversion.html" class="internal-link" target="_self" rel="noopener nofollow">04aa Analog to digital conversion</a>
<br><a data-href="04ab RaspberryPi GPIO header utilization" href="04ab-raspberrypi-gpio-header-utilization.html" class="internal-link" target="_self" rel="noopener nofollow">04ab RaspberryPi GPIO header utilization</a>
<br><br>
<br>
]]></description><link>99_navigation.html</link><guid isPermaLink="false">99_Navigation.md</guid><dc:creator><![CDATA[David Jun]]></dc:creator><pubDate>Sun, 16 Mar 2025 16:48:35 GMT</pubDate></item><item><title><![CDATA[ADS1115 chip (I2C)]]></title><description><![CDATA[ 
 <br><br><br>import time
import smbus

class ADS1115:
    # Default I2C address options
    ADDR_GND = 0x48  # ADDR pin connected to GND
    ADDR_VDD = 0x49  # ADDR pin connected to VDD
    ADDR_SDA = 0x4A  # ADDR pin connected to SDA
    ADDR_SCL = 0x4B  # ADDR pin connected to SCL
    
    # Register addresses
    REG_CONVERSION = 0x00
    REG_CONFIG = 0x01
    
    # Config register bits
    # Operational status / single-shot conversion start
    OS_MASK = 0x8000
    OS_SINGLE = 0x8000  # Write: Set to start a single-shot conversion
    OS_BUSY = 0x0000    # Read: 0 = busy, 1 = not busy
    OS_READY = 0x8000   # Read: 0 = busy, 1 = not busy
    
    # Input multiplexer configuration
    MUX_MASK = 0x7000
    MUX_DIFF_0_1 = 0x0000  # Differential P = AIN0, N = AIN1
    MUX_DIFF_0_3 = 0x1000  # Differential P = AIN0, N = AIN3
    MUX_DIFF_1_3 = 0x2000  # Differential P = AIN1, N = AIN3
    MUX_DIFF_2_3 = 0x3000  # Differential P = AIN2, N = AIN3
    MUX_SINGLE_0 = 0x4000  # Single-ended AIN0
    MUX_SINGLE_1 = 0x5000  # Single-ended AIN1
    MUX_SINGLE_2 = 0x6000  # Single-ended AIN2
    MUX_SINGLE_3 = 0x7000  # Single-ended AIN3
    
    # Programmable gain amplifier configuration
    PGA_MASK = 0x0E00
    PGA_6_144V = 0x0000  # ±6.144V range = Gain 2/3
    PGA_4_096V = 0x0200  # ±4.096V range = Gain 1
    PGA_2_048V = 0x0400  # ±2.048V range = Gain 2 (default)
    PGA_1_024V = 0x0600  # ±1.024V range = Gain 4
    PGA_0_512V = 0x0800  # ±0.512V range = Gain 8
    PGA_0_256V = 0x0A00  # ±0.256V range = Gain 16
    
    # Device operating mode
    MODE_MASK = 0x0100
    MODE_CONTIN = 0x0000  # Continuous conversion mode
    MODE_SINGLE = 0x0100  # Single-shot conversion mode (default)
    
    # Data rate (samples per second)
    DR_MASK = 0x00E0
    DR_8SPS = 0x0000    # 8 samples per second
    DR_16SPS = 0x0020   # 16 samples per second
    DR_32SPS = 0x0040   # 32 samples per second
    DR_64SPS = 0x0060   # 64 samples per second
    DR_128SPS = 0x0080  # 128 samples per second (default)
    DR_250SPS = 0x00A0  # 250 samples per second
    DR_475SPS = 0x00C0  # 475 samples per second
    DR_860SPS = 0x00E0  # 860 samples per second
    
    # Comparator mode
    COMP_MODE_MASK = 0x0010
    COMP_MODE_TRAD = 0x0000  # Traditional comparator with hysteresis (default)
    COMP_MODE_WINDOW = 0x0010  # Window comparator
    
    # Comparator polarity
    COMP_POL_MASK = 0x0008
    COMP_POL_ACTVLOW = 0x0000  # Active low (default)
    COMP_POL_ACTVHI = 0x0008   # Active high
    
    # Latching comparator
    COMP_LAT_MASK = 0x0004
    COMP_LAT_NONLAT = 0x0000  # Non-latching comparator (default)
    COMP_LAT_LATCH = 0x0004   # Latching comparator
    
    # Comparator queue and disable
    COMP_QUE_MASK = 0x0003
    COMP_QUE_1CONV = 0x0000  # Assert after one conversion
    COMP_QUE_2CONV = 0x0001  # Assert after two conversions
    COMP_QUE_4CONV = 0x0002  # Assert after four conversions
    COMP_QUE_DISABLE = 0x0003  # Disable comparator (default)
    
    # Conversion factor for voltage based on PGA setting
    VOLTAGE_FACTORS = {
        PGA_6_144V: 6.144 / 32768.0,
        PGA_4_096V: 4.096 / 32768.0,
        PGA_2_048V: 2.048 / 32768.0,
        PGA_1_024V: 1.024 / 32768.0,
        PGA_0_512V: 0.512 / 32768.0,
        PGA_0_256V: 0.256 / 32768.0
    }
    
    def __init__(self, bus_num=1, address=ADDR_GND, gain=PGA_2_048V):
        """Initialize the ADS1115 ADC."""
        self.bus = smbus.SMBus(bus_num)
        self.address = address
        self.gain = gain
        self.voltage_factor = self.VOLTAGE_FACTORS[gain]
    
    def _write_register(self, register, value):
        """Write a 16-bit value to the specified register."""
        data = [(value &gt;&gt; 8) &amp; 0xFF, value &amp; 0xFF]
        self.bus.write_i2c_block_data(self.address, register, data)
    
    def _read_register(self, register):
        """Read a 16-bit value from the specified register."""
        result = self.bus.read_i2c_block_data(self.address, register, 2)
        return (result[0] &lt;&lt; 8) | result[1]
    
    def set_gain(self, gain):
        """Set the PGA gain."""
        self.gain = gain
        self.voltage_factor = self.VOLTAGE_FACTORS[gain]
    
    def read_adc_single(self, channel, data_rate=DR_128SPS):
        """
        Read a single-ended ADC value from the specified channel.
        
        channel -- 0-3, the ADC channel to read
        data_rate -- Data rate setting (default DR_128SPS)
        
        Returns the ADC value as a signed 16-bit integer.
        """
        if channel &lt; 0 or channel &gt; 3:
            raise ValueError("Channel must be 0-3")
        
        # Select the appropriate mux value
        mux = self.MUX_SINGLE_0
        if channel == 1:
            mux = self.MUX_SINGLE_1
        elif channel == 2:
            mux = self.MUX_SINGLE_2
        elif channel == 3:
            mux = self.MUX_SINGLE_3
        
        # Set configuration register
        config = self.OS_SINGLE | mux | self.gain | self.MODE_SINGLE | data_rate | self.COMP_QUE_DISABLE
        
        # Write configuration to the ADC
        self._write_register(self.REG_CONFIG, config)
        
        # Wait for the conversion to complete
        time.sleep(1.0 / 128)  # Minimum delay, adjust for the actual data rate
        
        # Read the conversion result
        return self._read_register(self.REG_CONVERSION)
    
    def read_adc_differential(self, differential_input, data_rate=DR_128SPS):
        """
        Read a differential ADC value.
        
        differential_input -- 0-3, specifies which differential inputs to use:
            0 = AIN0 and AIN1
            1 = AIN0 and AIN3
            2 = AIN1 and AIN3
            3 = AIN2 and AIN3
            
        data_rate -- Data rate setting (default DR_128SPS)
        
        Returns the ADC value as a signed 16-bit integer.
        """
        if differential_input &lt; 0 or differential_input &gt; 3:
            raise ValueError("Differential input must be 0-3")
        
        # Select the appropriate mux value
        mux = self.MUX_DIFF_0_1
        if differential_input == 1:
            mux = self.MUX_DIFF_0_3
        elif differential_input == 2:
            mux = self.MUX_DIFF_1_3
        elif differential_input == 3:
            mux = self.MUX_DIFF_2_3
        
        # Set configuration register
        config = self.OS_SINGLE | mux | self.gain | self.MODE_SINGLE | data_rate | self.COMP_QUE_DISABLE
        
        # Write configuration to the ADC
        self._write_register(self.REG_CONFIG, config)
        
        # Wait for the conversion to complete
        time.sleep(1.0 / 128)  # Minimum delay, adjust for the actual data rate
        
        # Read the conversion result
        return self._read_register(self.REG_CONVERSION)
    
    def read_voltage(self, channel):
        """
        Read voltage from the specified ADC channel.
        
        channel -- 0-3, the ADC channel to read
        
        Returns the voltage as a float.
        """
        raw_value = self.read_adc_single(channel)
        # Convert to voltage
        voltage = raw_value * self.voltage_factor
        return voltage
    
    def read_differential_voltage(self, differential_input):
        """
        Read differential voltage.
        
        differential_input -- 0-3, specifies which differential inputs to use
        
        Returns the voltage as a float.
        """
        raw_value = self.read_adc_differential(differential_input)
        # Convert to voltage
        voltage = raw_value * self.voltage_factor
        return voltage

# Example usage
if __name__ == "__main__":
    # Initialize ADS1115
    adc = ADS1115()
    
    try:
        while True:
            # Read voltage from all channels
            for channel in range(4):
                voltage = adc.read_voltage(channel)
                print(f"Channel {channel}: {voltage:.4f} V")
            
            # Read differential voltage
            diff_voltage = adc.read_differential_voltage(0)
            print(f"Differential (0-1): {diff_voltage:.4f} V")
            
            print("---")
            time.sleep(1)
    except KeyboardInterrupt:
        print("Measurement stopped by user")
<br>The it can be chained with <a data-href="01aa02 Sensirion SDP810-125PA" href="01aa02-sensirion-sdp810-125pa.html" class="internal-link" target="_self" rel="noopener nofollow">01aa02 Sensirion SDP810-125PA</a> sensor to the same I2C pins:<br><br>
<br>Connect the SDP810-125Pa pressure sensor:

<br>VDD to 3.3V (pin 1)
<br>GND to GND (pin 6)
<br>SDA to SDA (pin 3)
<br>SCL to SCL (pin 5)


<br>Connect the ADS1115:

<br>VDD to 3.3V (pin 1)
<br>GND to GND (pin 6)
<br>SDA to SDA (pin 3)
<br>SCL to SCL (pin 5)
<br>ADDR to GND (for address 0x48)
<br>Connect your analog sensors to A0-A3 pins as needed


<br>Both devices use I2C, so they share the same SDA and SCL pins. The ADS1115 code I provided includes:<br>
<br>Single-ended readings (each channel against ground)
<br>Differential readings (between pairs of channels)
<br>Voltage conversion with configurable gain
<br>Support for all available data rates
<br>The code is thoroughly commented to help you understand how it works and how to modify it for your specific needs.<br>import time
import smbus

# Import the ADS1115 and SDP810 classes
from ads1115 import ADS1115
from sdp810 import SDP810

# Initialize the sensors
adc = ADS1115()
pressure_sensor = SDP810()

try:
    while True:
        # Read pressure from the SDP810
        pressure = pressure_sensor.read_pressure()
        if pressure is not None:
            print(f"Differential Pressure: {pressure:.2f} Pa")
        
        # Read voltage from the ADS1115
        # Assuming you have a sensor connected to channel 0
        voltage = adc.read_voltage(0)
        print(f"Voltage: {voltage:.4f} V")
        
        # You can add more code here to process the readings
        # For example, convert voltage to a physical measurement
        
        print("---")
        time.sleep(1)
except KeyboardInterrupt:
    print("Measurement stopped by user")
    # Clean up
    try:
        pressure_sensor.stop_measurement()
    except:
        pass
<br>The conversion code is mentioned in the <a data-href="00aa01 Omron D6F-P" href="00aa01-omron-d6f-p.html" class="internal-link" target="_self" rel="noopener nofollow">00aa01 Omron D6F-P</a> note.]]></description><link>04aa01-ads1115-chip-(i2c).html</link><guid isPermaLink="false">04aa01 ADS1115 chip (I2C).md</guid><dc:creator><![CDATA[David Jun]]></dc:creator><pubDate>Sun, 16 Mar 2025 17:26:32 GMT</pubDate></item><item><title><![CDATA[Flowres - Hardware]]></title><description><![CDATA[ 
 <br><br>This vault serves as a knowledge base for the hardware of the mostly printed flow resistivity measurement setup. The outline of the vault is given in <a class="internal-link" data-href="99_Navigation.md" href="99_navigation.html" target="_self" rel="noopener nofollow">Navigation</a>.<br><img alt="model_v1_png" src="attachments/model_v1.png"><br>The 3D printed parts are modelled in <a data-tooltip-position="top" aria-label="https://www.freecadweb.org/" rel="noopener nofollow" class="external-link" href="https://www.freecadweb.org/" target="_blank">FreeCAD</a>, a free and open-source<br>
parametric 3D CAD software. The models are stored in the models directory of the <a data-tooltip-position="top" aria-label="https://www.github.com/vyhyb/flowres-hardware" rel="noopener nofollow" class="external-link" href="https://www.github.com/vyhyb/flowres-hardware" target="_blank"><code></code></a>flowres-hardware repository on GitHub<br>The software part of the project can be found <a data-tooltip-position="top" aria-label="https://www.github.com/vyhyb/flowres" rel="noopener nofollow" class="external-link" href="https://www.github.com/vyhyb/flowres" target="_blank">here</a>.<br>This vault is exported as a website and can be viewed <a data-tooltip-position="top" aria-label="https://vyhyb.github.io/flowres-hardware/" rel="noopener nofollow" class="external-link" href="https://vyhyb.github.io/flowres-hardware/" target="_blank">here</a>.<br><br>
<br>
<a data-tooltip-position="top" aria-label="https://www.fce.vutbr.cz/o-fakulte/lide/david-jun-12801/" rel="noopener nofollow" class="external-link" href="https://www.fce.vutbr.cz/o-fakulte/lide/david-jun-12801/" target="_blank">David Jun</a>
PhD student at <a data-tooltip-position="top" aria-label="https://www.vutbr.cz/en/" rel="noopener nofollow" class="external-link" href="https://www.vutbr.cz/en/" target="_blank">Brno University of Technology</a>.

<br><br>Pull requests are welcome. For any changes, please open an issue first<br>
to discuss what you would like to change.<br>Please make sure to update tests as appropriate.<br><br><a data-tooltip-position="top" aria-label="https://choosealicense.com/licenses/gpl-3.0/" rel="noopener nofollow" class="external-link" href="https://choosealicense.com/licenses/gpl-3.0/" target="_blank">GNU GPLv3</a><br>Flowres-Hardware - Hardware for the mostly printed flow resistivity measurement setup<br>Copyright (C) 2025 David Jun<br>This program is free software: you can redistribute it and/or modify<br>
it under the terms of the GNU General Public License as published by<br>
the Free Software Foundation, either version 3 of the License, or<br>
(at your option) any later version.<br>This program is distributed in the hope that it will be useful,<br>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<br>
GNU General Public License for more details.<br>You should have received a copy of the GNU General Public License<br>
along with this program.  If not, see <a rel="noopener nofollow" class="external-link" href="https://www.gnu.org/licenses/" target="_blank">https://www.gnu.org/licenses/</a>.<br><br>[1] ČSN EN ISO 9053-1 - Akustika - Stanovení odporu proti proudění vzduchu - část 1: Metoda statického proudění vzduchu, manual, Praha., 2019.]]></description><link>index.html</link><guid isPermaLink="false">index.md</guid><dc:creator><![CDATA[David Jun]]></dc:creator><pubDate>Sun, 16 Mar 2025 13:05:51 GMT</pubDate><enclosure url="attachments/model_v1.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="attachments/model_v1.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Omron D6F-A3]]></title><description><![CDATA[ 
 <br><br><img alt="Attachments/00aa01 Omron D6F-P picture.png" src="attachments/00aa01-omron-d6f-p-picture.png" style="width: 300px; max-width: 100%;"><br>An analog <a data-tooltip-position="top" aria-label="00aa Analog flow sensors" data-href="00aa Analog flow sensors" href="00aa-analog-flow-sensors.html" class="internal-link" target="_self" rel="noopener nofollow">flow sensor</a>. An alternative to <a data-href="00aa01 Omron D6F-P" href="00aa01-omron-d6f-p.html" class="internal-link" target="_self" rel="noopener nofollow">00aa01 Omron D6F-P</a> for higher flow rates.<br>The flow rate range is 0-3 l/min. It is powered with 12 V.<br>This could be a valid option for measurements outside the range recommended by <a data-href="ISO 9053-1 Requirements" href="ISO 9053-1 Requirements" class="internal-link" target="_self" rel="noopener nofollow">ISO 9053-1 Requirements</a> or for larger sample sizes.<br>The price for this unit is around €170 on <a data-tooltip-position="top" aria-label="https://cz.mouser.com/ProductDetail/Omron-Electronics/D6F-03A3-000?qs=93uzuGORGqeobncO0atalw%3D%3D" rel="noopener nofollow" class="external-link" href="https://cz.mouser.com/ProductDetail/Omron-Electronics/D6F-03A3-000?qs=93uzuGORGqeobncO0atalw%3D%3D" target="_blank">Mouser</a><br>Note that such sensor needs to be paired with a decent&nbsp;<a data-tooltip-position="top" aria-label="app://obsidian.md/04aa%20Analog%20to%20digital%20conversion" rel="noopener nofollow" class="external-link" href="/04aa Analog to digital conversion" target="_blank">ADC</a>.<br><br><img alt="Attachments/00aa02 Omron D6F-A3 output voltages.png" src="attachments/00aa02-omron-d6f-a3-output-voltages.png"><br><br><img alt="Attachments/00aa02 Omron D6F-A3 characteristics.png" src="attachments/00aa02-omron-d6f-a3-characteristics.png"><br>Given the accuracy of 5% FS, one should not expect to reliably measure bellow 0.15 l/min.<br><br><a data-tooltip-position="top" aria-label="Attachments/datasheets/en_d6f_series-1128136.pdf" data-href="Attachments/datasheets/en_d6f_series-1128136.pdf" href="attachments/datasheets/en_d6f_series-1128136.pdf" class="internal-link" target="_self" rel="noopener nofollow">Datasheet</a>]]></description><link>00aa02-omron-d6f-a3.html</link><guid isPermaLink="false">00aa02 Omron D6F-A3.md</guid><dc:creator><![CDATA[David Jun]]></dc:creator><pubDate>Sun, 16 Mar 2025 16:39:11 GMT</pubDate><enclosure url="attachments/00aa01-omron-d6f-p-picture.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="attachments/00aa01-omron-d6f-p-picture.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Omron D6F-P]]></title><description><![CDATA[ 
 <br><br><img alt="Attachments/00aa01 Omron D6F-P picture-1.png" src="attachments/00aa01-omron-d6f-p-picture-1.png" style="width: 300px; max-width: 100%;"><br>An analog <a data-tooltip-position="top" aria-label="00aa Analog flow sensors" data-href="00aa Analog flow sensors" href="00aa-analog-flow-sensors.html" class="internal-link" target="_self" rel="noopener nofollow">flow sensor</a>.<br>There are two main variants:<br>
<br>0 - 0.1 l/min
<br>0 - 1 l/min
<br>Given the general <a data-href="ISO 9053-1 Requirements" href="ISO 9053-1 Requirements" class="internal-link" target="_self" rel="noopener nofollow">ISO 9053-1 Requirements</a>, both can be a reasonable option based on the specimen surface area of choice.<br>Both variants can be bought for approx. €40 at <a data-tooltip-position="top" aria-label="https://cz.mouser.com/c/?marcom=115753066" rel="noopener nofollow" class="external-link" href="https://cz.mouser.com/c/?marcom=115753066" target="_blank">Mouser</a> and probably also elsewhere.<br>Note that such sensor needs to be paired with a decent <a data-tooltip-position="top" aria-label="04aa Analog to digital conversion" data-href="04aa Analog to digital conversion" href="04aa-analog-to-digital-conversion.html" class="internal-link" target="_self" rel="noopener nofollow">ADC</a>.<br><br><img alt="Attachments/Omron D6F-P output voltages.png" src="attachments/omron-d6f-p-output-voltages.png"><br><br><img alt="Attachments/Omron D6F-P characteristics.png" src="attachments/omron-d6f-p-characteristics.png"><br>The choice of flow sensor depends on the dimensions (The target flow speed across the specimen is 0.5 mm/s, while the sensors are typically volumetric or mass based). For square samples, the target flow rate would be:<br>
<br>102 mm side - 0.3 l/min
<br>45 mm side - 0.06 l/min<br>
Given the 5% FS accuracy, the 0-1 l/min variant gives the error of , which is already probably too much for the smaller mentioned sample size. On the other hand, the measurement can consist of many sequential takes at different flow rates (as implemented in the <a data-tooltip-position="top" aria-label="https://github.com/vyhyb/flowres/tree/main" rel="noopener nofollow" class="external-link" href="https://github.com/vyhyb/flowres/tree/main" target="_blank">flowres</a> package), which gives a more valuable information about the sample behavior. Based on such argument, the 0-1 l/min variant is probably more suited.
<br><br><a data-tooltip-position="top" aria-label="Attachments/datasheets/en_d6f_series-1128136.pdf" data-href="Attachments/datasheets/en_d6f_series-1128136.pdf" href="attachments/datasheets/en_d6f_series-1128136.pdf" class="internal-link" target="_self" rel="noopener nofollow">Datasheet</a><br><br>Given the <a data-tooltip-position="top" aria-label="https://claude.ai/" rel="noopener nofollow" class="external-link" href="https://claude.ai/" target="_blank">Claude AI</a>. Should be debugged for later use. Features the <a data-href="04aa01 ADS1115 chip (I2C)" href="04aa01-ads1115-chip-(i2c).html" class="internal-link" target="_self" rel="noopener nofollow">04aa01 ADS1115 chip (I2C)</a> and <a data-href="01aa02 Sensirion SDP810-125PA" href="01aa02-sensirion-sdp810-125pa.html" class="internal-link" target="_self" rel="noopener nofollow">01aa02 Sensirion SDP810-125PA</a>.<br>import numpy as np
from scipy import interpolate
import time
from ads1115 import ADS1115
from sdp810 import SDP810

class FlowSensorConverter:
    """
    Convert voltage readings from Omron D6F-P flow sensor to flow rates
    using spline interpolation of calibration values.
    """
    
    def __init__(self, calibration_dict, interpolation_kind='cubic'):
        """
        Initialize the converter with calibration values.
        
        Parameters:
        calibration_dict -- Dictionary with {flow_rate: voltage} pairs
        interpolation_kind -- Type of spline interpolation ('linear', 'cubic', etc.)
        """
        # Extract flow rates and voltages from the dictionary
        flow_rates = list(calibration_dict.keys())
        voltages = list(calibration_dict.values())
        
        # Sort them by voltage to ensure proper interpolation
        sorted_pairs = sorted(zip(voltages, flow_rates))
        voltages_sorted = [pair[0] for pair in sorted_pairs]
        flow_rates_sorted = [pair[1] for pair in sorted_pairs]
        
        # Create the interpolation function
        # Note: we're creating voltage-&gt;flow interpolation since we'll be measuring voltage
        self.interpolator = interpolate.interp1d(
            voltages_sorted,
            flow_rates_sorted,
            kind=interpolation_kind,
            bounds_error=False,  # Don't raise error for out-of-bounds values
            fill_value=(flow_rates_sorted[0], flow_rates_sorted[-1])  # Extrapolate with edge values
        )
    
    def voltage_to_flow(self, voltage):
        """
        Convert voltage reading to flow rate using the calibration spline.
        
        Parameters:
        voltage -- The voltage reading from the sensor (float)
        
        Returns:
        flow_rate -- The interpolated flow rate
        """
        return float(self.interpolator(voltage))

class OmronD6FP:
    """
    Interface for Omron D6F-P flow sensor using ADS1115 for analog reading.
    """
    
    def __init__(self, adc, adc_channel=0, calibration_dict=None):
        """
        Initialize the sensor interface.
        
        Parameters:
        adc -- Instance of ADS1115 class
        adc_channel -- The ADC channel the sensor is connected to (0-3)
        calibration_dict -- Dictionary with {flow_rate: voltage} pairs for calibration
        """
        self.adc = adc
        self.adc_channel = adc_channel
        
        # Use default calibration if none provided
        if calibration_dict is None:
            # Example calibration values for D6F-P - REPLACE WITH ACTUAL VALUES
            calibration_dict = {
                0.0: 1.0,    # 0 L/min -&gt; 1.0V
                5.0: 2.0,    # 5 L/min -&gt; 2.0V
                10.0: 3.0,   # 10 L/min -&gt; 3.0V
                20.0: 4.0,   # 20 L/min -&gt; 4.0V
                50.0: 5.0    # 50 L/min -&gt; 5.0V
            }
        
        self.converter = FlowSensorConverter(calibration_dict)
    
    def read_voltage(self):
        """Read raw voltage from the sensor."""
        return self.adc.read_voltage(self.adc_channel)
    
    def read_flow(self):
        """Read and convert sensor voltage to flow rate."""
        voltage = self.read_voltage()
        return self.converter.voltage_to_flow(voltage)

# Example usage
if __name__ == "__main__":
    # Initialize the ADC
    adc = ADS1115()
    
    # Example calibration for demonstration (replace with actual values from datasheet)
    # Format: {flow_rate (L/min): output_voltage (V)}
    d6f_calibration = {
        0.0: 1.0,
        5.0: 1.5,
        10.0: 2.0,
        20.0: 3.0,
        30.0: 4.0,
        50.0: 5.0
    }
    
    # Initialize the flow sensor
    flow_sensor = OmronD6FP(adc, adc_channel=0, calibration_dict=d6f_calibration)
    
    # Optional: Initialize pressure sensor
    try:
        pressure_sensor = SDP810()
        pressure_available = True
    except:
        print("Pressure sensor not available")
        pressure_available = False
    
    try:
        while True:
            # Read flow rate
            flow_voltage = flow_sensor.read_voltage()
            flow_rate = flow_sensor.read_flow()
            print(f"Flow sensor voltage: {flow_voltage:.3f} V")
            print(f"Flow rate: {flow_rate:.2f} L/min")
            
            # Read pressure if available
            if pressure_available:
                pressure = pressure_sensor.read_pressure()
                if pressure is not None:
                    print(f"Differential Pressure: {pressure:.2f} Pa")
            
            print("---")
            time.sleep(1)
    except KeyboardInterrupt:
        print("Measurement stopped by user")
        # Clean up
        if pressure_available:
            try:
                pressure_sensor.stop_measurement()
            except:
                pass
]]></description><link>00aa01-omron-d6f-p.html</link><guid isPermaLink="false">00aa01 Omron D6F-P.md</guid><dc:creator><![CDATA[David Jun]]></dc:creator><pubDate>Sun, 16 Mar 2025 17:27:24 GMT</pubDate><enclosure url="attachments/00aa01-omron-d6f-p-picture-1.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="attachments/00aa01-omron-d6f-p-picture-1.png"&gt;&lt;/figure&gt;</content:encoded></item></channel></rss>